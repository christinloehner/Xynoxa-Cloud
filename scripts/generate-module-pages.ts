#!/usr/bin/env tsx
/*
 * Copyright (C) 2025 Christin LÃ¶hner
 */
/**
 * Generate App Router wrapper pages for module routes.
 *
 * This keeps Next.js route manifests stable while still allowing Plug&Play modules.
 */

import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const APP_DIR = path.join(__dirname, "../src/app/(dashboard)");
const MARKER = "// @generated by scripts/generate-module-pages.ts";

async function ensureDir(p: string) {
  await fs.mkdir(p, { recursive: true });
}

async function exists(p: string) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

function toRouteSegments(routePath: string) {
  return routePath.replace(/^\//, "").split("/");
}

function buildFilePath(routePath: string) {
  const segments = toRouteSegments(routePath);
  return path.join(APP_DIR, ...segments, "page.tsx");
}

function buildWrapperContent(moduleId: string, routePath: string) {
  return `${MARKER}
import { renderModulePage } from "@/lib/module-route-resolver";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

export default async function ModuleWrapperPage({ params, searchParams }: { params: Record<string, string | string[]>; searchParams: Record<string, string | string[] | undefined> }) {
  return renderModulePage(${JSON.stringify(moduleId)}, ${JSON.stringify(routePath)}, params, searchParams);
}
`;
}

async function removeStaleGeneratedPages(expected: Set<string>) {
  const entries = await fs.readdir(APP_DIR, { withFileTypes: true });

  async function walk(dir: string) {
    const list = await fs.readdir(dir, { withFileTypes: true });
    for (const entry of list) {
      const full = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await walk(full);
        const remaining = await fs.readdir(full).catch(() => []);
        if (remaining.length === 0) {
          await fs.rmdir(full).catch(() => {});
        }
        continue;
      }
      if (entry.name !== "page.tsx") continue;
      const content = await fs.readFile(full, "utf8").catch(() => "");
      if (!content.includes(MARKER)) continue;
      if (!expected.has(full)) {
        await fs.unlink(full).catch(() => {});
      }
    }
  }

  await walk(APP_DIR);
}

async function main() {
  const { ROUTE_MODULES } = await import("@/lib/module-registry.route");

  const routes = ROUTE_MODULES.flatMap((mod) => (mod.routes ?? []).map((route) => ({ moduleId: mod.metadata.id, route })));
  const targetFiles = new Set<string>();

  for (const entry of routes) {
    const { moduleId, route } = entry;
    if (!route.path || !route.path.startsWith("/")) continue;
    const filePath = buildFilePath(route.path);
    targetFiles.add(filePath);
    const dir = path.dirname(filePath);
    await ensureDir(dir);

    const content = buildWrapperContent(moduleId, route.path);
    const shouldWrite = !(await exists(filePath)) || (await fs.readFile(filePath, "utf8").catch(() => "")).includes(MARKER);
    if (shouldWrite) {
      await fs.writeFile(filePath, content, "utf8");
    }
  }

  await removeStaleGeneratedPages(targetFiles);
  console.log(`[Module Pages] Generated ${targetFiles.size} route wrappers`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
